#Operating Systems
#Fall '24
#Assignment 1
#Steven Rios

class Process:
    #create the vairables needed in the program 
    def __init__(self, pid, arrival_time, burst_time):
        self.pid = pid
        self.arrival_time = arrival_time
        self.burst_time = burst_time
        self.remaining_time = burst_time
        self.waiting_time = 0
        self.turnaround_time = 0

def fcfs_scheduling(processes):
    processes.sort(key=lambda x: x.arrival_time)
    current_time = 0

    for process in processes:
        if current_time < process.arrival_time:
            current_time = process.arrival_time
        process.waiting_time = current_time - process.arrival_time
        process.turnaround_time = process.waiting_time + process.burst_time
        current_time += process.burst_time 

    return processes

def sjf_scheduling(processes):
    processes.sort(key=lambda x: (x.arrival_time, x.burst_time))
    current_time = 0
    ready_queue = []
    completed_processes = []

    while any(process.burst_time > 0 for process in processes):
        # Add processes to ready queue 
        for process in processes:
            if process.arrival_time <= current_time and process not in ready_queue:
                ready_queue.append(process)

        # Find the shortest job 
        if ready_queue:
            shortest_job = min(ready_queue, key=lambda x: x.burst_time)
            ready_queue.remove(shortest_job)

            # Execute the shortest job
            shortest_job.waiting_time = current_time - shortest_job.arrival_time
            shortest_job.turnaround_time = shortest_job.waiting_time + shortest_job.burst_time
            current_time += shortest_job.burst_time
            completed_processes.append(shortest_job)

    return completed_processes

def srt_scheduling(processes):
    current_time = 0
    ready_queue = []

    while any(process.remaining_time > 0 for process in processes):
        # Add processes to ready queue 
        for process in processes:
            if process.arrival_time <= current_time and process not in ready_queue:
                ready_queue.append(process)

        # Find the process with the shortest remaining time
        if ready_queue:
            shortest_remaining_job = min(ready_queue, key=lambda x: x.remaining_time)

            # If the shortest remaining job is different from the currently running job, preempt
            if current_process and current_process.remaining_time > shortest_remaining_job.remaining_time:
                current_process.remaining_time -= current_time - current_process.start_time
                ready_queue.append(current_process)
                current_process = None

            # If there's no current process or the shortest remaining job is the same, start or continue executing 
            if not current_process:
                current_process = shortest_remaining_job
                current_process.start_time = current_time

            # Update remaining time and check for completion
            current_process.remaining_time -= 1
            if current_process.remaining_time == 0:
                current_process.turnaround_time = current_time - current_process.arrival_time
                current_process.waiting_time = current_process.turnaround_time - current_process.burst_time
                current_process = None

        # Increment time
        current_time += 1

    return processes

def round_robin_scheduling(processes, time_quantum):
    current_time = 0
    ready_queue = []

    while any(process.remaining_time > 0 for process in processes):
        # Add processes to ready queue
        for process in processes:
            if process.arrival_time <= current_time and process not in ready_queue:
                ready_queue.append(process)

        # If there are processes in the ready queue
        if ready_queue:
            current_process = ready_queue.pop(0)

            # Execute the process for the time quantum or until completion
            if current_process.remaining_time > time_quantum:
                current_process.remaining_time -= time_quantum
                current_time += time_quantum
            else:
                current_time += current_process.remaining_time
                current_process.remaining_time = 0
                current_process.turnaround_time = current_time - current_process.arrival_time
                current_process.waiting_time = current_process.turnaround_time - current_process.burst_time

            # If the process is not finished, add it back to the end of the queue
            if current_process.remaining_time > 0:
                ready_queue.append(current_process)

    return processes

def display_results(algorithm_name, processes):
    print(f"Results for {algorithm_name}:")

    # Create a table header
    print("Process ID\tArrival Time\tBurst Time\tWaiting Time\tTurnaround Time")
    print("----------\t------------\t----------\t------------\t--------------")

    # Use list comprehension for efficient data formatting
    data = [{'Process ID': process.pid, 'Arrival Time': process.arrival_time,
             'Burst Time': process.burst_time, 'Waiting Time': process.waiting_time,
             'Turnaround Time': process.turnaround_time} for process in processes]

    # Print each process data in a formatted way
    for row in data:
        print(f"\t\t{row['Process ID']}\t\t\t{row['Arrival Time']}\t\t\t\t{row['Burst Time']}\t\t\t\t{row['Waiting Time']}\t\t\t\t{row['Turnaround Time']}")

# Example usage
processes = [
    Process(1, 0, 8),
    Process(2, 1, 4),
    Process(3, 2, 9),
    Process(4, 3, 5)
]

# Choose a scheduling algorithm
scheduled_processes = fcfs_scheduling(processes)  # Replace with SJF, SRT, or RR as needed

# Display results for the chosen algorithm
display_results("FCFS", scheduled_processes)  # Replace with the appropriate algorithm name
